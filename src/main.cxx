/*! 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The Maglev calibration software
FLTK 1.3 was used for the GUI
Generated by Fast Light User Interface Designer (fluid) version 1.0304

    \author Navid Fallahinia
    \date   Updated: Feb 11, 2018

  <B>Supervisor:</B>                               \n
  Dr. Stephen Mascaro                              \n
  <B>Location:</B>                                 \n
  University of Utha, Robotics Center:             \n
  Bio-Robotics Laboratory                          \n
*/


//=========================================================
//   The header files and include
//=========================================================

#include "main.h"
#include "CameraControl.h"
#include "Images.h"
#include <stdio.h>
#include <unistd.h>
#include "ImageDisplay.h"
static char demo_dir[] = "~/haptics/bin/"; 
static CameraControl camera_m; 
static Images image_buff; 
static Training current_training; 
static bool flag_camera_on = false; 
static bool flag_force_ready = false; 
static bool flag_start_training = false; 
static bool flag_camera_capture = false;
static bool flag_thumb = false; 
static int image_counter = 0; 
static char data_dir[] = "../data_files/data_00_0_00x/"; 
#define GAIN_TEXT 10

//=========================================================
//========== The fucntions and buttons handles ============
//========================================================= 

Fl_Double_Window *control_window=(Fl_Double_Window *)0;

Plot2DView *box_maglev_rotation=(Plot2DView *)0;

Graph3DAxis *box_maglev_position=(Graph3DAxis *)0;

CubeView *display_force=(CubeView *)0;

Fl_Group *maglev_position=(Fl_Group *)0;

Fl_Group *position_gain_sliders=(Fl_Group *)0;

Fl_Group *position_gain_sliders_x=(Fl_Group *)0;

Fl_Value_Slider *position_gain_x_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_x_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_x_D=(Fl_Value_Slider *)0;

Fl_Group *position_gain_sliders_y=(Fl_Group *)0;

Fl_Value_Slider *position_gain_y_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_y_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_y_D=(Fl_Value_Slider *)0;

Fl_Group *position_gain_sliders_z=(Fl_Group *)0;

Fl_Value_Slider *position_gain_z_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_z_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_z_D=(Fl_Value_Slider *)0;

Fl_Group *rotation_gain_sliders_x=(Fl_Group *)0;

Fl_Value_Slider *rotation_gain_x_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_x_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_x_D=(Fl_Value_Slider *)0;

Fl_Group *rotation_gain_sliders_y=(Fl_Group *)0;

Fl_Value_Slider *rotation_gain_y_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_y_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_y_D=(Fl_Value_Slider *)0;

Fl_Group *rotation_gain_sliders_z=(Fl_Group *)0;

Fl_Value_Slider *rotation_gain_z_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_z_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_z_D=(Fl_Value_Slider *)0;

Fl_Button *button_maglev_connect_separate=(Fl_Button *)0;

Fl_Button *button_maglev_lift_land_separate=(Fl_Button *)0;

Fl_Value_Slider *slider_maglev_frequency=(Fl_Value_Slider *)0;

Fl_Check_Button *check_calibrate_thumb=(Fl_Check_Button *)0;

Fl_Group *force_controller=(Fl_Group *)0;

Fl_Group *force_gain_sliders=(Fl_Group *)0;

Fl_Group *force_gain_sliders_x=(Fl_Group *)0;

Fl_Value_Slider *force_gain_x_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *force_gain_x_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *force_gain_x_D=(Fl_Value_Slider *)0;

Fl_Group *force_gain_sliders_y=(Fl_Group *)0;

Fl_Value_Slider *force_gain_y_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *force_gain_y_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *force_gain_y_D=(Fl_Value_Slider *)0;

Fl_Group *force_gain_sliders_z=(Fl_Group *)0;

Fl_Value_Slider *force_gain_z_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *force_gain_z_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *force_gain_z_D=(Fl_Value_Slider *)0;

Fl_Group *target_forces=(Fl_Group *)0;

Fl_Value_Slider *desired_force_x=(Fl_Value_Slider *)0;

Fl_Value_Slider *desired_force_y=(Fl_Value_Slider *)0;

Fl_Value_Slider *desired_force_z=(Fl_Value_Slider *)0;

Fl_Group *target_positions=(Fl_Group *)0;

Fl_Value_Slider *desired_position_x=(Fl_Value_Slider *)0;

Fl_Value_Slider *desired_position_y=(Fl_Value_Slider *)0;

Fl_Value_Slider *desired_position_z=(Fl_Value_Slider *)0;

Fl_Value_Slider *desired_rotation_x=(Fl_Value_Slider *)0;

Fl_Value_Slider *desired_rotation_y=(Fl_Value_Slider *)0;

Fl_Value_Slider *desired_rotation_z=(Fl_Value_Slider *)0;

Fl_Button *start_force_controller_separate=(Fl_Button *)0;

Fl_Group *system_id=(Fl_Group *)0;

Fl_Value_Slider *slide_force_magnitude=(Fl_Value_Slider *)0;

Fl_Value_Slider *slide_force_power=(Fl_Value_Slider *)0;

Fl_Text_Display *force_frequency=(Fl_Text_Display *)0;

Fl_Group *camera_control=(Fl_Group *)0;

Fl_Group *camera_settings=(Fl_Group *)0;

Fl_Value_Slider *camera_brightness=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_exposure=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_gamma=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_shutter=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_framerate=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_gain=(Fl_Value_Slider *)0;

Fl_Button *camera_load_settings=(Fl_Button *)0;

Fl_Button *camera_save_settings=(Fl_Button *)0;

Fl_Button *button_start_camera_separate=(Fl_Button *)0;

Fl_Button *button_record=(Fl_Button *)0;

ImageDisplay *image_display_b=(ImageDisplay *)0;

Fl_Group *training_trajectories=(Fl_Group *)0;

Fl_Group *all_together=(Fl_Group *)0;

ImageDisplay *image_display_m=(ImageDisplay *)0;

Fl_Choice *trajectory_index=(Fl_Choice *)0;

Fl_Output *training_percent=(Fl_Output *)0;

Fl_Output *training_file_name=(Fl_Output *)0;

Fl_Progress *training_progress=(Fl_Progress *)0;

Fl_Button *save_data=(Fl_Button *)0;

Fl_Choice *subject_index=(Fl_Choice *)0;

Fl_Choice *trajectory_type=(Fl_Choice *)0;

Fl_Choice *finger_index=(Fl_Choice *)0;

Fl_Button *button_maglev_connect=(Fl_Button *)0;

Fl_Button *button_maglev_lift_land=(Fl_Button *)0;

Fl_Button *button_start_camera=(Fl_Button *)0;

Fl_Button *start_force_controller=(Fl_Button *)0;

Fl_Button *start_training=(Fl_Button *)0;

Fl_Input *training_file_name_separate=(Fl_Input *)0;

Fl_Button *read_trajectory_file_separate=(Fl_Button *)0;

Fl_Double_Window *PopupCameraWindow=(Fl_Double_Window *)0;

ForceSensor force_sensor_m; 

MaglevControl maglev_m; 

//=========================================================
//==================   The functions    ===================
//========================================================= 

static void cb_button_maglev_connect_separate(Fl_Button*, void*) {
  // Check the current state of the Maglev
    if (maglev_m.flag_maglev_start)
    {
            // Synchronize the buttons
            button_maglev_connect_separate->clear();
            button_maglev_connect->clear();
            
            // Land the Maglev, if needed
            if ( button_maglev_lift_land -> value() )
            {
                    button_maglev_lift_land_separate->clear();
                    button_maglev_lift_land->clear();
            }
            
            // Turn off the Maglev
            maglev_m.maglevTurnOff ( );
            
            // Activate the thumb checkboxes
            finger_index->activate();
            check_calibrate_thumb->activate();
    }
    else
    {
            // Synchronize the buttons
            button_maglev_connect_separate->set();
            button_maglev_connect->set();
            
            // Start the force sensor
            force_sensor_m.startForceSensor();
            
            // Turn on the "draw force reading" callback
            printf("Turning on a callback to draw the force sensor readings (%5.3f)\n", 1.0/FORCE_FREQUENCY);
            Fl::add_timeout(1.0/FORCE_FREQUENCY, forceSensorReading);
            display_force->flag_force_display = true;
            
            // Connect to the Maglev
            maglev_m.maglevConnect (  );
            
            // Deactivate the Thumb Calibration checkbox
            finger_index->deactivate();
            check_calibrate_thumb->deactivate();
            
            // Turn on the "draw maglev position" callback
            printf("Turning on a callback to draw the Maglev position readings (%5.3f)\n", 1.0/MAGLEV_FREQUENCY);
            Fl::add_timeout(1.0/MAGLEV_FREQUENCY, draw_maglev_position);
    };
}

static void cb_button_maglev_lift_land_separate(Fl_Button*, void*) {
  // Make sure the maglev has been started
    if (maglev_m.flag_maglev_start)
    {
            if (button_maglev_lift_land_separate->value())
            {
                    // Make sure the "real" button matches this one
                    button_maglev_lift_land->set();
                    
                    // Have the Maglev take off
                    maglev_m.maglevTakeOff ( flag_thumb );
                    
                    // Load the Maglev internal gains into the slider bars
                    update_gain_sliders();
                    
                    // Load the Maglev operating frequency into the slider bar
                    slider_maglev_frequency->value(maglev_m.maglevGetFrequency( ));
            }
            else
            {
                    // Make sure the "real" button matches this one
                    button_maglev_lift_land->clear();
                    
                    // Land the Maglev
                    maglev_m.maglevLand (  );
            }
    }
    else
    {
            // Turn off this button and the one on the "real" tab
            button_maglev_lift_land_separate->clear();
            button_maglev_lift_land->clear();
    };
}

static void cb_slider_maglev_frequency(Fl_Value_Slider*, void*) {
  maglev_m.maglevSetFrequency( slider_maglev_frequency->value() );
}

static void cb_check_calibrate_thumb(Fl_Check_Button*, void*) {
  // Make sure the drop-down box matches this one
    if (check_calibrate_thumb->value())
    {
            finger_index->value(1);
            flag_thumb = true;
            desired_force_x->value(1.0);
            desired_force_x->maximum(0.5);
            desired_force_x->minimum(10.0);
            desired_force_x->step(0.5);
            desired_force_z->value(0.0);
            desired_force_z->maximum(-5.0);
            desired_force_z->minimum(5.0);
            desired_force_z->step(0.25);
            maglev_m.desired_force[0] = 1.5;
            maglev_m.desired_force[2] = 0.0;
    }
    else
    {
            finger_index->value(2);
            flag_thumb = false;
            desired_force_x->value(0.0);
            desired_force_x->maximum(-5.0);
            desired_force_x->minimum(5.0);
            desired_force_x->step(0.25);
            desired_force_z->value(-1.0);
            desired_force_z->maximum(-10.0);
            desired_force_z->minimum(-0.5);
            desired_force_z->step(0.5);
            maglev_m.desired_force[0] = 0.0;
            maglev_m.desired_force[2] = -1.5;
    }
    generate_trajectory_file();
}

static void cb_start_force_controller_separate(Fl_Button*, void*) {
  // Determine whether the external controller is running
    if (maglev_m.flag_force_control_start)
    {
            // Synchronize both buttons -- Shutting off the external controller
            start_force_controller->clear();
            start_force_controller_separate->clear();
            
            // Stop the force controller
            maglev_m.maglevStopForceController();
            update_gain_sliders();
    }
    else if(maglev_m.flag_maglev_start && force_sensor_m.flag_force_sensor)
    {
            // Synchronize both buttons -- Turning on the external controller
            start_force_controller->set();
            start_force_controller_separate->set();
            
            // Set the desired forces to the values shown on the sliders
            maglev_m.desired_force[0] = desired_force_x->value();
            maglev_m.desired_force[1] = desired_force_y->value();
            maglev_m.desired_force[2] = desired_force_z->value();
            
            // Start the force controller
    	maglev_m.maglevStartForceController();
    }
    else
    {
            // Synchronize both buttons -- The external controller will not be running
            start_force_controller->clear();
            start_force_controller_separate->clear();
            
            // Explain to the user why the external force controller is not going to start
            printf("Cannot start the external controller:\n");
            if (!maglev_m.flag_maglev_start)
            {
                    printf("\tThe Maglev is not on!\n");
            }
            if (!force_sensor_m.flag_force_sensor)
            {
                    printf("\tThe force sensor is not on!\n");
            }
    };
}

static void cb_Save(Fl_Button*, void*) {
  maglev_m.maglevSaveGains();
}

static void cb_Save1(Fl_Button*, void*) {
  // Code to start saving the force data
    // Verify that the data directory exists
    update_data_dir();
    if(access(data_dir,F_OK))
    {
    	printf("===========================\nThe data directory does not exist...creating it!\n===========================\n");
    	int error = mkdir(data_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    	if(error > 0)
    	{
    		printf("Could not create data directory!!\n");
    		return;
    	}
    }

    // Tell the Maglev to start saving the force
    maglev_m.maglevSaveForce();
}

static void cb_Stop(Fl_Button*, void*) {
  // Code to stop saving the force data
    // Tell the Maglev to stop saving the force data
    maglev_m.maglevStopSaveForce();
}

static void cb_button_start_camera_separate(Fl_Button*, void*) {
  if (button_start_camera_separate->value())
    {
        // printf("HERE_1!!!!!!1");
        // Make sure the "real" button on the all_together tab is synchronized
        button_start_camera->set();
        
        // Start the camera
        camera_m.initCamera();
        camera_m.startCamera();
        
        // Determine the size of the camera images and allocate memory for an image
        int cols = camera_m.num_cols;
        int rows = camera_m.num_rows;
        int inc = camera_m.num_colors;
        unsigned char temp_image[cols*rows*inc];
        
        // Get a new image from the camera
        camera_m.grabImage();
        camera_m.getImage( temp_image );
        
        // Write the image to the image buffer
        image_buff.writeImage( rows, cols, inc, temp_image );
        
        //Set the timers for taking new images and displaying them
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, takeImage, NULL);
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, displayImage, NULL);
        
        // Set the "camera on" flag
        flag_camera_on = 1;
    }
    else
    {
      // printf("HERE_2!!!!!!");
      // Make sure the "real" button on the all_together tab is synchronized
      button_start_camera->clear();

      // Turn the camera off
      Fl::remove_timeout(takeImage, NULL);
      Fl::remove_timeout(displayImage, NULL);
      flag_camera_on = 0;

      // Wait for the last callback to run
      Fl::wait(3);

      // Remove the camera handles
      camera_m.turnOffCamera();
    };
}

static void cb_(Fl_Button*, void*) {
  //if ( flag_camera_start )
    //	fl_draw_image ( current_image, display_x, display_y, display_w, display_h, 3, 0);
}

static void cb_button_record(Fl_Button*, void*) {
  // CAMERA_TEST_CODE;
}

static void cb_Select(Fl_Button*, void*) {
    /*training_browser->load(".", 1);


    training_file_name->value( training_browser->text(training_browser->value()) );
    */
    Fl_File_Chooser* fc = new Fl_File_Chooser("../trajGen/large_trajectory","Text Files (*.{txt,dat,tex})",Fl_File_Chooser::SINGLE,"Text File");
    fc->callback(fileChooserCallback);
    fc->show();
}

static void cb_read_trajectory_file_separate(Fl_Button*, void*){
    //Load the training trajectory from the file
    // Read the trajectory file
    current_training.ReadTrajectoryFile(training_file_name->value());

    if (!current_training.flag_trajectory_ready)
    {
            printf("The trajectory file did not read correctly!\n");
            return;
    };
}

static void cb_Start(Fl_Button*, void*){
  //Check other things are ready
    // Verify that the data directory exists
    update_data_dir();
    if(access(data_dir,F_OK))
    {
	printf("===========================\nThe data directory does not exist...creating it!\n===========================\n");
	int error = mkdir(data_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	if(error > 0)
	{
		printf("Could not create data directory!!\n");
		return;
	}
    }

    // Load the training trajectory from the file
    if (!current_training.flag_trajectory_ready)
    {
            // Try to read the trajectory file
            current_training.ReadTrajectoryFile(training_file_name->value());
            if (!current_training.flag_trajectory_ready)
            {
                    printf("The trajectory file did not read correctly!\n");
                    return;
            }
    }

    if ((!flag_camera_on) || (!maglev_m.flag_force_control_start))
    {
            if (!flag_camera_on)
                    printf("The camera is off!\n");
            if (!maglev_m.flag_force_control_start)
                    printf("The force controller is off!\n");
            printf("Please correct these problems and try again!\n");
            return;
    }

    // Set flags
    flag_force_ready = false; // Marks when the Sensor is measuring the desired force
    flag_start_training = true; // True until the trajectory has finished

    // Set the progress bar to 0%
    training_progress->value(0.0);
    training_percent->value("0.0");

    printf("It will take %5.2f minutes.\n", current_training.max_count * (((double)(current_training.ramp_max + current_training.hold_min))/TRAINING_FREQUENCY)/60.0);

    //Set a timer for training recording
    Fl::add_timeout(1.0/TRAINING_FREQUENCY, record_training_images, NULL);
}

static void cb_save_data(Fl_Button*, void*) {
  // Start/Stop saving force controller data
    // Disable the button until the Saving/Resetting is finished
    save_data->deactivate();

    // Change behavior based on toggle value of the button
    if (!save_data->value())
    {
            // If the button is pressed, stop saving data
            maglev_m.maglevStopSaveForce();
            
            // Change the label on the button
            save_data->label("Save Data");
    }
    else
    {
            // If the button is not pressed, start saving data
            
            // Verify that the data directory exists
            update_data_dir();
            if(access(data_dir,F_OK))
            {
    	        printf("===========================\nThe data directory does not exist...creating it!\n===========================\n");
    	        int error = mkdir(data_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    	        if(error > 0)
    	        {
    		        printf("Could not create data directory!!\n");
    		        return;
    	        }
            }
            
            // Tell the Maglev to start saving the force
            maglev_m.maglevSaveForce();
            
            // Change the label on the button
            save_data->label("Stop Save");
    }

    // Re-enable the button
    save_data->activate();
}

static void cb_button_maglev_connect(Fl_Button*, void*) {
  // Check the current state of the Maglev
    if (maglev_m.flag_maglev_start)
    {
            // Synchronize the buttons
            button_maglev_connect_separate->clear();
            button_maglev_connect->clear();
            
            
            // Reactivate the Lift/Land button
            if ( button_maglev_lift_land -> value() )
            {
                    button_maglev_lift_land_separate->clear();
                    button_maglev_lift_land->clear();
            }
            maglev_m.maglevTurnOff ( );
            
            // Reactivate the finger selection box
            finger_index->activate();
            check_calibrate_thumb->activate();
            
            // Reset the "Save Data" button
            save_data->activate();
            save_data->clear();
            save_data->label("Save Data");
    }
    else
    {
            // Synchronize the buttons
            button_maglev_connect_separate->set();
            button_maglev_connect->set();
            
            // Start the force sensor
            force_sensor_m.startForceSensor();
            
            // Turn on the "draw force reading" callback
            printf("Turning on a callback to draw the force sensor readings (%5.3f)\n", 1.0/FORCE_FREQUENCY);
            Fl::add_timeout(1.0/FORCE_FREQUENCY, forceSensorReading);
            display_force->flag_force_display = true;
            
            // Connect to the Maglev
            maglev_m.maglevConnect (  );
            
            // Deactivate the Thumb Calibration checkbox
            finger_index->deactivate();
            check_calibrate_thumb->deactivate();
            
            // Turn on the "draw maglev position" callback
            printf("Turning on a callback to draw the Maglev position/rotation readings.\n");
            Fl::add_timeout(1.0/MAGLEV_FREQUENCY, draw_maglev_position);
    };
}

static void cb_button_maglev_lift_land(Fl_Button*, void*) {
  // Make sure the maglev has been started
    if (maglev_m.flag_maglev_start)
    {
            // Make sure the "separate" button is synchronized this one
            if (button_maglev_lift_land->value())
            {
                    // Synchronize the "separate" button on the maglev_control tab
                    button_maglev_lift_land_separate->set();
                    
                    // Have the Maglev take off
                    maglev_m.maglevTakeOff ( flag_thumb );
                    
                    // Set the values of the gain sliders
                    update_gain_sliders();
                    
                    // Set the Frequency slider
                    slider_maglev_frequency->value(maglev_m.maglevGetFrequency( ));
            }
            else
            {
                    // Synchronize the "separate" button on the maglev_control tab
                    button_maglev_lift_land_separate->clear();
                    
                    // Land the Maglev
                    maglev_m.maglevLand (  );
            }
    }
    else
    {
            // Clear this button and the "separate" button on the maglev_control tab
            button_maglev_lift_land->clear();
            button_maglev_lift_land_separate->clear();
    };
}

static void cb_button_start_camera(Fl_Button*, void*) {
  // Start the camera
  if (button_start_camera->value())
    {
        // Make sure the "separate" button on the camera_control tab is synchronized
        button_start_camera_separate->set();
        
        // Start the camera
        camera_m.initCamera();
        camera_m.startCamera();
        
        // Determine the size of the camera images and allocate memory for an image
        int cols = camera_m.num_cols;
        int rows = camera_m.num_rows;
        int inc = camera_m.num_colors;
        unsigned char temp_image[cols*rows*inc];
        
        // Get a new image from the camera
        camera_m.grabImage();
        camera_m.getImage( temp_image );
        
        // Write the image to the image buffer
        image_buff.writeImage( rows, cols, inc, temp_image );
        
        //Set the timers for taking new images and displaying them
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, takeImage, NULL);
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, displayImage, NULL);
        
        // Set the "camera on" flag
        flag_camera_on = 1;
    }
    else
    {
        // Make sure the "separate" button on the camera_control tab is synchronized
        button_start_camera_separate->clear();
        
        // Turn the camera off
        Fl::remove_timeout(takeImage, NULL);
        Fl::remove_timeout(displayImage, NULL);
        flag_camera_on = 0;
        
        // Wait for the last callback to run
        Fl::wait(3);
        
        // Remove the camera handles
        camera_m.turnOffCamera();
    };
}

static void cb_start_force_controller(Fl_Button*, void*) {
  // Determine whether the external controller is running
    if (maglev_m.flag_force_control_start)
    {
            // Synchronize both buttons -- Shutting off the external controller
            start_force_controller->clear();
            start_force_controller_separate->clear();
            
            // Stop the force controller
            maglev_m.maglevStopForceController();
            update_gain_sliders();
    }
    else if(maglev_m.flag_maglev_start && force_sensor_m.flag_force_sensor)
    {
            // Synchronize both buttons -- Turning on the external controller
            start_force_controller->set();
            start_force_controller_separate->set();
            
            // Set the desired forces to the values shown on the sliders
            maglev_m.desired_force[0] = desired_force_x->value();
            maglev_m.desired_force[1] = desired_force_y->value();
            maglev_m.desired_force[2] = desired_force_z->value();
            
            // Start the force controller
    	maglev_m.maglevStartForceController();
    }
    else
    {
            // Synchronize both buttons -- The external controller will not be running
            start_force_controller->clear();
            start_force_controller_separate->clear();
            
            // Explain to the user why the external force controller is not going to start
            printf("Cannot start the external controller:\n");
            if (!maglev_m.flag_maglev_start)
            {
                    printf("\tThe Maglev is not on!\n");
            }
            if (!force_sensor_m.flag_force_sensor)
            {
                    printf("\tThe force sensor is not on!\n");
            }
    };
}

static void cb_start_training(Fl_Button*, void*) {
  // Start/Stop the training trajectory
    // Check whether the training trajectory is already running
    if (flag_start_training)
    {
            // If it is running, then stop it
            flag_start_training = false;
            start_training->label("Start");
    }
    else
    {
            // Re-generate trajectory file
            generate_trajectory_file();
            update_data_dir();
            
            // Verify that the data directory exists
            if(access(data_dir,F_OK))
            {
    	        printf("===========================\nThe data directory does not exist...creating it!\n===========================\n");
    	        int error = mkdir(data_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    	        if(error > 0)
    	        {
    		        printf("Got an error!\n");
    	        }
            }
            
            // Load the training trajectory from the file
            current_training.ReadTrajectoryFile(training_file_name->value());
            
            // Verify that the following conditions have been met:
            //      (1) Camera is on
            //      (2) Maglev force controller is on
            //      (3) Trajectory file was successfully read
            if ( (!flag_camera_on) || (!maglev_m.flag_force_control_start) || (!current_training.flag_trajectory_ready))
            {
                    if (!flag_camera_on)
                            printf("The camera is off!\n");
                    if (!maglev_m.flag_force_control_start)
                            printf("The force controller is off!\n");
                    if (!current_training.flag_trajectory_ready)
                            printf("The trajectory file did not read correctly!\n");
                    printf("Please correct these problems and try again!\n");
                    start_training->clear();
                    return;
            }
            
            // Set flags
            flag_force_ready = false; // Marks when the Sensor is measuring the desired force
            flag_start_training = true; // True until the trajectory has finished
            start_training->label("Stop");
            
            // Set the progress bar to 0%
            training_progress->value(0.0);
            training_percent->value("0.0");
            
            printf("It will take %5.2f minutes.\n", current_training.max_count * (((double)(current_training.ramp_max + current_training.hold_min))/TRAINING_FREQUENCY)/60.0);
            
            //Set a timer for training recording
            Fl::add_timeout(1.0/TRAINING_FREQUENCY, record_training_images, NULL);
    };
}

void update_desired_force() {
  // Code to update the desired Maglev force
  if ((maglev_m.flag_maglev_start) && (maglev_m.flag_force_control_start) && (!flag_start_training))
  {
          // Set the desired force
          maglev_m.desired_force[0] = desired_force_x->value();
          maglev_m.desired_force[1] = desired_force_y->value();
          maglev_m.desired_force[2] = desired_force_z->value();
  }
}

void update_desired_position() {
  // Code to update the desired Maglev position
  if ((maglev_m.flag_maglev_start) && (!flag_start_training))
  {
          // Set desired position, converting millimeters to meters
          maglev_m.desired_position.values[0] = desired_position_x->value() / 1000.0;
          maglev_m.desired_position.values[1] = desired_position_y->value() / 1000.0;
          maglev_m.desired_position.values[2] = desired_position_z->value() / 1000.0;
          
          // Set desired rotation, converting degrees to radians
          maglev_m.desired_position.values[3] = desired_rotation_x->value() * PI / 180.0;
          maglev_m.desired_position.values[4] = desired_rotation_y->value() * PI / 180.0;
          maglev_m.desired_position.values[5] = desired_rotation_z->value() * PI / 180.0;
          
          // Send the command to the Maglev
          maglev_m.maglevSetDesiredPosition();
  }
}

void update_controller_gains() {
  // Code to update the controller gains
  if ( maglev_m.flag_maglev_start )
  {
          if (maglev_m.flag_force_control_start)
          {
                  ////////////////////////////////////////////////////////////////
                  // Set the force gains to the values of the sliders
                  ////////////////////////////////////////////////////////////////
                  
                  // x-direction force gains
                  maglev_m.current_gains_force[0][0] = force_gain_x_P->value();
                  maglev_m.current_gains_force[0][1] = force_gain_x_I->value();
                  maglev_m.current_gains_force[0][2] = force_gain_x_D->value();
                  
                  // y-direction force gains
                  maglev_m.current_gains_force[1][0] = force_gain_y_P->value();
                  maglev_m.current_gains_force[1][1] = force_gain_y_I->value();
                  maglev_m.current_gains_force[1][2] = force_gain_y_D->value();
                  
                  // z-direction force gains
                  maglev_m.current_gains_force[2][0] = force_gain_z_P->value();
                  maglev_m.current_gains_force[2][1] = force_gain_z_I->value();
                  maglev_m.current_gains_force[2][2] = force_gain_z_D->value();
                  
                  ////////////////////////////////////////////////////////////////
                  // Set the position gains to the values of the sliders
                  ////////////////////////////////////////////////////////////////
                  
                  // Set the values for the x-position axis
                  maglev_m.current_gains_position[0][0] = position_gain_x_P->value();
                  maglev_m.current_gains_position[0][1] = position_gain_x_I->value();
                  maglev_m.current_gains_position[0][2] = position_gain_x_D->value();
                  
                  // Set the values for the y-position axis
                  maglev_m.current_gains_position[1][0] = position_gain_y_P->value();
                  maglev_m.current_gains_position[1][1] = position_gain_y_I->value();
                  maglev_m.current_gains_position[1][2] = position_gain_y_D->value();
                  
                  // Set the values for the z-position axis
                  maglev_m.current_gains_position[2][0] = position_gain_z_P->value();
                  maglev_m.current_gains_position[2][1] = position_gain_z_I->value();
                  maglev_m.current_gains_position[2][2] = position_gain_z_D->value();
                  
                  // Set the values for the x-rotation axis
                  maglev_m.current_gains_position[3][0] = rotation_gain_x_P->value();
                  maglev_m.current_gains_position[3][1] = rotation_gain_x_I->value();
                  maglev_m.current_gains_position[3][2] = rotation_gain_x_D->value();
                  
                  // Set the values for the y-rotation axis
                  maglev_m.current_gains_position[4][0] = rotation_gain_y_P->value();
                  maglev_m.current_gains_position[4][1] = rotation_gain_y_I->value();
                  maglev_m.current_gains_position[4][2] = rotation_gain_y_D->value();
                  
                  // Set the values for the z-rotation axis
                  maglev_m.current_gains_position[5][0] = rotation_gain_z_P->value();
                  maglev_m.current_gains_position[5][1] = rotation_gain_z_I->value();
                  maglev_m.current_gains_position[5][2] = rotation_gain_z_D->value();
          }
          else
          {
                  ////////////////////////////////////////////////////////////////
                  // Set the internal position gains to the values of the sliders
                  ////////////////////////////////////////////////////////////////
  
                  // Set the values for the x-position axis
                  maglev_m.current_gains_internal[0][0] = position_gain_x_P->value();
                  maglev_m.current_gains_internal[0][1] = position_gain_x_I->value();
                  maglev_m.current_gains_internal[0][2] = position_gain_x_D->value();
                  
                  // Set the values for the y-position axis
                  maglev_m.current_gains_internal[1][0] = position_gain_y_P->value();
                  maglev_m.current_gains_internal[1][1] = position_gain_y_I->value();
                  maglev_m.current_gains_internal[1][2] = position_gain_y_D->value();
                  
                  // Set the values for the z-position axis
                  maglev_m.current_gains_internal[2][0] = position_gain_z_P->value();
                  maglev_m.current_gains_internal[2][1] = position_gain_z_I->value();
                  maglev_m.current_gains_internal[2][2] = position_gain_z_D->value();
                  
                  // Set the values for the x-rotation axis
                  maglev_m.current_gains_internal[3][0] = rotation_gain_x_P->value();
                  maglev_m.current_gains_internal[3][1] = rotation_gain_x_I->value();
                  maglev_m.current_gains_internal[3][2] = rotation_gain_x_D->value();
                  
                  // Set the values for the y-rotation axis
                  maglev_m.current_gains_internal[4][0] = rotation_gain_y_P->value();
                  maglev_m.current_gains_internal[4][1] = rotation_gain_y_I->value();
                  maglev_m.current_gains_internal[4][2] = rotation_gain_y_D->value();
                  
                  // Set the values for the z-rotation axis
                  maglev_m.current_gains_internal[5][0] = rotation_gain_z_P->value();
                  maglev_m.current_gains_internal[5][1] = rotation_gain_z_I->value();
                  maglev_m.current_gains_internal[5][2] = rotation_gain_z_D->value();
                  
                  // Set the Maglev's internal gains to the new values
                  maglev_m.maglevSetInternalGains();
          }
  }
}

void update_gain_sliders() {
  // Code to update the gain sliders goes here
  
  ////////////////////////////////////////////////////////////////////////
  // Set the force control sliders to the values of the force gains
  ////////////////////////////////////////////////////////////////////////
  
  // x-direction force gains
  force_gain_x_P->value(maglev_m.current_gains_force[0][0]);
  force_gain_x_I->value(maglev_m.current_gains_force[0][1]);
  force_gain_x_D->value(maglev_m.current_gains_force[0][2]);
  
  // y-direction force gains
  force_gain_y_P->value(maglev_m.current_gains_force[1][0]);
  force_gain_y_I->value(maglev_m.current_gains_force[1][1]);
  force_gain_y_D->value(maglev_m.current_gains_force[1][2]);
  
  // z-direction force gains
  force_gain_z_P->value(maglev_m.current_gains_force[2][0]);
  force_gain_z_I->value(maglev_m.current_gains_force[2][1]);
  force_gain_z_D->value(maglev_m.current_gains_force[2][2]);
  
  // Check whether the force controller is running
  if (maglev_m.flag_force_control_start)
  {
          ////////////////////////////////////////////////////////////////////////
          // Set the position control sliders to the values of the position gains
          ////////////////////////////////////////////////////////////////////////
          
          // x-direction position gains
          position_gain_x_P->value(maglev_m.current_gains_position[0][0]);
          position_gain_x_I->value(maglev_m.current_gains_position[0][1]);
          position_gain_x_D->value(maglev_m.current_gains_position[0][2]);
          
          // y-direction position gains
          position_gain_y_P->value(maglev_m.current_gains_position[1][0]);
          position_gain_y_I->value(maglev_m.current_gains_position[1][1]);
          position_gain_y_D->value(maglev_m.current_gains_position[1][2]);
          
          // z-direction position gains
          position_gain_z_P->value(maglev_m.current_gains_position[2][0]);
          position_gain_z_I->value(maglev_m.current_gains_position[2][1]);
          position_gain_z_D->value(maglev_m.current_gains_position[2][2]);
          
          // x-direction rotation gains
          rotation_gain_x_P->value(maglev_m.current_gains_position[3][0]);
          rotation_gain_x_I->value(maglev_m.current_gains_position[3][1]);
          rotation_gain_x_D->value(maglev_m.current_gains_position[3][2]);
          
          // y-direction rotation gains
          rotation_gain_y_P->value(maglev_m.current_gains_position[4][0]);
          rotation_gain_y_I->value(maglev_m.current_gains_position[4][1]);
          rotation_gain_y_D->value(maglev_m.current_gains_position[4][2]);
          
          // z-direction rotation gains
          rotation_gain_z_P->value(maglev_m.current_gains_position[5][0]);
          rotation_gain_z_I->value(maglev_m.current_gains_position[5][1]);
          rotation_gain_z_D->value(maglev_m.current_gains_position[5][2]);
  }
  else
  {
          ////////////////////////////////////////////////////////////////////////
          // Set the position control sliders to the values of the position gains
          ////////////////////////////////////////////////////////////////////////
          
          // x-direction position gains
          position_gain_x_P->value(maglev_m.current_gains_internal[0][0]);
          position_gain_x_I->value(maglev_m.current_gains_internal[0][1]);
          position_gain_x_D->value(maglev_m.current_gains_internal[0][2]);
          
          // y-direction position gains
          position_gain_y_P->value(maglev_m.current_gains_internal[1][0]);
          position_gain_y_I->value(maglev_m.current_gains_internal[1][1]);
          position_gain_y_D->value(maglev_m.current_gains_internal[1][2]);
          
          // z-direction position gains
          position_gain_z_P->value(maglev_m.current_gains_internal[2][0]);
          position_gain_z_I->value(maglev_m.current_gains_internal[2][1]);
          position_gain_z_D->value(maglev_m.current_gains_internal[2][2]);
          
          // x-direction rotation gains
          rotation_gain_x_P->value(maglev_m.current_gains_internal[3][0]);
          rotation_gain_x_I->value(maglev_m.current_gains_internal[3][1]);
          rotation_gain_x_D->value(maglev_m.current_gains_internal[3][2]);
          
          // y-direction rotation gains
          rotation_gain_y_P->value(maglev_m.current_gains_internal[4][0]);
          rotation_gain_y_I->value(maglev_m.current_gains_internal[4][1]);
          rotation_gain_y_D->value(maglev_m.current_gains_internal[4][2]);
          
          // z-direction rotation gains
          rotation_gain_z_P->value(maglev_m.current_gains_internal[5][0]);
          rotation_gain_z_I->value(maglev_m.current_gains_internal[5][1]);
          rotation_gain_z_D->value(maglev_m.current_gains_internal[5][2]);
  }
}

void forceSensorReading(void *) {
  if (display_force->flag_force_display)
  {
          // Read a new set of data from the force sensor
          if (!maglev_m.flag_force_control_start)
          {
                  force_sensor_m.readNewData();
          }
          
          // Set the height of the bars in the force display
          display_force->height_x = force_sensor_m.curr_force.force[0];
          display_force->height_y = force_sensor_m.curr_force.force[1];
          display_force->height_z = force_sensor_m.curr_force.force[2];
          display_force->height_rx = force_sensor_m.curr_force.force[3];
          display_force->height_ry = force_sensor_m.curr_force.force[4];
          display_force->height_rz = force_sensor_m.curr_force.force[5];
          display_force->redraw();
          //printf("%5.2f | %5.2f | %5.2f\n", force_sensor_m.curr_force.time, force_sensor_m.curr_force.force[0], display_force->height_x);
  }
  //printf("Reading the force (%10.6f | %10.6f | %10.6f)\n", force_sensor_m.curr_force.time, force_sensor_m.curr_force.force[2], display_force->height_z);
  
  // Set up the next iteration of this timer
  Fl::repeat_timeout(1.0/FORCE_FREQUENCY, forceSensorReading);
}

int tick_callback_handler( ml_device_handle_t maglev_handle,  ml_position_t *maglev_position ) {
  // Code to execute on each "tick" goes here
  // Verify that the force sensor has been started
  if (display_force->flag_force_display)
  {
          // Get a new force sensor reading
          force_sensor_m.readNewData();
  }
  
  // Verify that the Maglev force controller is running
  if (maglev_m.flag_force_control_start)
  {
          // Run the Maglev Controller
          if (maglev_m.maglevController ( force_sensor_m.curr_force))
          {
                  update_gain_sliders();
          }
  }
  else
  {
          for (int i=0; i<6; i++)
          {
                  maglev_m.current_position.values[i] = (*maglev_position).values[i];
          }
  }
  
  // Set the return value
  return 0;
}

int fault_callback_handler( ml_device_handle_t maglev_handle,  ml_fault_t maglev_fault ) {
  // Fault-handling code goes here
  // Detect all fault types currently registered
  if(maglev_fault.value != ML_FAULT_TYPE_CLEAR)
  {
          printf("Faults currently registered: (");
          // If a fault has occurred, determine whether one of the
          //      components is an out-of-range fault
          if (maglev_fault.value >= ML_FAULT_TYPE_FLOTOR_OVERSPEED)
          {
                  // Flotor moving too fast
                  maglev_fault.value -= ML_FAULT_TYPE_FLOTOR_OVERSPEED;
                  printf("Flotor_Speed");
          }
          if (maglev_fault.value >= ML_FAULT_TYPE_COIL_OVERCURRENT)
          {
                  // Coil current too high
                  maglev_fault.value -= ML_FAULT_TYPE_COIL_OVERCURRENT;
                  printf("Coil_Current ");
          }
          if (maglev_fault.value >= ML_FAULT_TYPE_COIL_OVERTEMP)
          {
                  // Coil too hot
                  maglev_fault.value -= ML_FAULT_TYPE_COIL_OVERTEMP;
                  printf("Coil_Temp ");
          }
          if (maglev_fault.value >= ML_FAULT_TYPE_SENSOR_OUT_OF_RANGE)
          {
                  // Sensor out of range
                  maglev_fault.value -= ML_FAULT_TYPE_SENSOR_OUT_OF_RANGE;
                  printf("Sensor_Range");
          }
          if (maglev_fault.value != ML_FAULT_TYPE_CLEAR)
          {
                  printf(" ERROR - Unknown fault detected!");
                  return 1;
          }
          printf(")\n");
  }
  return 0;
}

int temp_callback_handler( ml_device_handle_t maglev_handle,  ml_temps_t *maglev_temps ) {
  // Code to handle "overtemp" callback goes here
  printf("Overtemp violation! (");
  for (int i=0; i < 6; i++)
  {
          printf("%9.4f ", (*maglev_temps).values[i]);
  }
  printf(")\n");
  return 0;
}

int boundary_callback_handler( ml_device_handle_t maglev_handle,  ml_boundary_violation_t *maglev_boundary ) {
  // Code to handle "boundary violation" callback goes here
  printf("Boundary violation! (");
  for (int i=0; i < 6; i++)
  {
          printf("%d ", (*maglev_boundary).values[i]);
  }
  printf(")\n");
  return 0;
}

void draw_maglev_position(void *) {
  // Continue running this timer as long as the Maglev is connected
  if (maglev_m.flag_maglev_start)
  {
          // Update the Maglev's translational position reading in the display
          // Set the height of the bars in the position display
          box_maglev_position->set3DAxis( maglev_m.current_position.values );
          box_maglev_position->redraw();
    
          // Update the Maglev's rotational position reading display
          box_maglev_rotation->height_x = maglev_m.current_position.values[3];
          box_maglev_rotation->height_y = maglev_m.current_position.values[4];
          box_maglev_rotation->height_z = maglev_m.current_position.values[5];
          box_maglev_rotation->redraw();
          
          // Update one of the Maglev's variables, based on the update_variable
          //      (0) temperatures, (1) currents or (2) forces.
    if (maglev_m.update_variable == 0)
    {
            // Update the temperatures
            maglev_m.maglevGetTemperature();
            maglev_m.update_variable = 1;
    }
    else if (maglev_m.update_variable == 1)
    {
            // Update the currents
            maglev_m.maglevGetCurrent();
            maglev_m.update_variable = 2;
            //maglev_m.update_variable = 0;
    }
    else if (maglev_m.update_variable == 2)
    {
            // Update the internal forces
            maglev_m.maglevGetForce();
            maglev_m.update_variable = 0;
    }
    else
    {
            // Since it has somehow been assigned an unapproved value, reset
            //      the update_variable so temperature will be processed
            //      next.
            maglev_m.update_variable = 0;
    }
          
          // Set up the timer for the next update
          Fl::repeat_timeout(1.0/MAGLEV_FREQUENCY, draw_maglev_position);
  }
}

void displayImage(void *) {
  // Code to display the current image buffer image
  //Display the image
  int cols = image_buff.cols;
  int rows = image_buff.rows;
  int inc = image_buff.inc;
  unsigned char temp_image[cols * rows * inc];
  image_buff.readImage(temp_image);
  // printf("Image res is cols=%d, rows=%d, inc= %d \n",cols, rows, inc);
  image_display_m->readImage(temp_image, cols, rows, inc);
  image_display_m->redraw();
  image_display_b->readImage(temp_image, cols, rows, inc);
  image_display_b->redraw();
  Fl::repeat_timeout(1.0 / CAMERA_FREQUENCY, displayImage, NULL);
}

void takeImage(void *) {
  // Code to record a new image from the camera
  if (flag_camera_on)
  { //take a new image image
    int cols = camera_m.num_cols;
    int rows = camera_m.num_rows;
    int inc = camera_m.num_colors;
    unsigned char temp_image[cols * rows * inc];
    camera_m.grabImage();
    camera_m.getImage(temp_image);
    image_buff.writeImage(temp_image);

    Fl::repeat_timeout(1.0 / CAMERA_FREQUENCY, takeImage, NULL);
  }
}

void fileChooserCallback(Fl_File_Chooser* o, void* v) {
  //printf("Chose %s!\n", o -> value());
  training_file_name->value(o -> value());
  training_file_name_separate->value(o -> value());
}

void update_data_dir() {
  // Update the data directory name
  // Get the label of the current selection in trajectory_index
  const Fl_Menu_Item* miTraj = trajectory_index->mvalue();
  
  char* traj_type;
  if (trajectory_type->value() == 0)
  {
          traj_type = "a";
  }
  else
  {
          traj_type = "b";
  }
  
  // Generate the training file name
  sprintf(data_dir, "../data_files/data_%02d_%d_%s%s/", subject_index->value(), finger_index->value(), miTraj->label(), traj_type);
  maglev_m.maglevSetSaveFileName(data_dir);
}

void generate_trajectory_file() {
  // Generate the trajectory file name
  // Get the label of the current selection in trajectory_index
  const Fl_Menu_Item* miTraj = trajectory_index->mvalue();
  
  char training_file[100];
  char* finger_name;
  char* traj_type;
  if (finger_index->value() == 1)
  {
          finger_name = "thumb";
  }
  else
  {
          finger_name = "finger";
  }
  if (trajectory_type->value() == 0)
  {
          traj_type = "a";
  }
  else
  {
          traj_type = "b";
  }
  
  // Generate the training file name
  sprintf(training_file, "../trajGen/large_trajectory/%s_%s%s.txt", finger_name, miTraj->label(), traj_type);
  training_file_name->value(training_file);
}

void change_finger() {
  // Code for when the drop-down box is changed
  // Split based on whether the thumb or a finger is selected
  if (finger_index->value() == 1)
  {
          // Synchronize the checkbox with the drop-down box
          check_calibrate_thumb->set();
          
          // Set the flag that the thumb is being used
          flag_thumb = true;
          
          // Reset the sliders for Desired Force in X and Z
          desired_force_x->value(1.5);
          desired_force_x->maximum(10.0);
          desired_force_x->minimum(0.5);
          desired_force_x->step(0.5);
          desired_force_z->value(0.0);
          desired_force_z->maximum(-5.0);
          desired_force_z->minimum(5.0);
          desired_force_z->step(0.25);
          
          // Set the desired force in x and z on the Maglev
          maglev_m.desired_force[0] = 1.5;
          maglev_m.desired_force[2] = 0.0;
  }
  else
  {
          check_calibrate_thumb->clear();
          flag_thumb = false;
          desired_force_x->value(0.0);
          desired_force_x->maximum(-5.0);
          desired_force_x->minimum(5.0);
          desired_force_x->step(0.25);
          desired_force_z->value(-1.5);
          desired_force_z->maximum(-10.0);
          desired_force_z->minimum(-0.5);
          desired_force_z->step(0.5);
          maglev_m.desired_force[0] = 0.0;
          maglev_m.desired_force[2] = -1.5;
  }
  
  // Change the trajectory file name, as needed
  generate_trajectory_file();
}

void record_training_images(void *) {
  // Record training results
  // Set up the counter
  static int counter = 0;
  
  // If the force is ready, record an image
  if ((flag_force_ready) && (flag_start_training))
    {
        // Record the image
        int cols = image_buff.cols;
        int rows = image_buff.rows;
        int inc = image_buff.inc;
        unsigned char temp_image[cols*rows*inc];
        image_buff.readImage( temp_image );
              
        // Clear the flag so that the controller can go forward
        current_training.current_count +=1;

        // Set the flag so that the force controller can go to next desired force
        flag_force_ready = false;

        //Save the force into the image
        // Fx, Fy are assumed to lie in [-6 N, +6 N] while Fz
        // lies in [-11 N, 1 N].  Thus the total range is the same
        // but with a different offset.  Both of these ranges are
        // mapped to the pixel range [0, 255].  Since at this time
        // we actually don't intend to go beyond a 10 N range for
        // any of the directions, there is some wasted space, but
        // this should catch any data in a reasonable range outside
        // that desired range.  This will give an accuracy of up to
        // 0.05 N in any direction.
        temp_image[0] = floor(21.25*(force_sensor_m.curr_force.force[0] + 6.0));
        temp_image[1] = floor(21.25*(force_sensor_m.curr_force.force[1] + 6.0));
        temp_image[2] = floor(21.25*(1.0 - force_sensor_m.curr_force.force[2]));

        //Save the torque into the image
        // All torques are assumed to lie in [-200 N-mm, +200 N-mm].  This range
        // is mapped to the pixel range [0, 255].  As with the forces, there is
        // expected to be some wasted space, since it appears that the torques
        // never exceed +/-100 N-mm.  However, as with the forces, this is
        // expected to catch data just outside the expected range.  (Any data
        // fully outside the expected range will "wrap around" to the other end
        // of the scale.)  This will give an accuracy of up to 1.5 N-mm in any
        // direction.  We aren't worried about torques at this point but want to
        // record them for possible future use.
        temp_image[3] = floor(0.6375*(force_sensor_m.curr_force.force[3] + 200.0));
        temp_image[4] = floor(0.6375*(force_sensor_m.curr_force.force[4] + 200.0));
        temp_image[5] = floor(0.6375*(force_sensor_m.curr_force.force[5] + 200.0));

        //Save image to a filename
        char filename[100];
        sprintf(filename, "%simg_%04d.ppm", data_dir, current_training.current_count );
        if (!ppm_write( filename, cols, rows, temp_image))
        {
                printf("Incorrectly wrote image (%d)!\n", current_training.current_count);
                return;
        }

        // Update the progress bar
        double progress_percent = ( (float) current_training.current_count) / ( (float) current_training.max_count ) * 100.0;
        char progress_string[7];
        sprintf(progress_string, "%6.2f%%", progress_percent);
        training_progress->value(progress_percent);
        training_percent->value(progress_string);

              // Turn off the training trajectory
        if ( current_training.current_count >= current_training.max_count )
        {
            printf("The training is done\n");
            flag_start_training = false;
        }
              
              // Start the timer again
              Fl::repeat_timeout(1.0/TRAINING_FREQUENCY, record_training_images, NULL);
    }
  else if (!flag_force_ready)
    {
          // If the force sensor is on and a training trajectory is active, update
          //   the desired force using the "ramp-and-hold"
          static float new_force[6];
          static float old_force[6];
          
          // Determine where the timing is in the "ramp-and-hold" trajectory
    if ( current_training.ramp_count == 0 )
    {
            // Starting at the beginning of the ramp
            
            // Process each force direction to determine the new and old forces
        for (int i=0; i<6; i++)
        {
                if (maglev_m.force_control_directions[i])
                {
                        // Read the new force from the trajectory array
                                  if (flag_start_training)
                    {
                            new_force[i] = current_training.traj[i][current_training.current_count];
                    }
                    
                    // If at the beginning of the trajectory, the old force is the current force.
                    //   Otherwise, it is the previous force in the trajectory array.
                    if ( current_training.current_count == 0 )
                    {
                        old_force[i] = force_sensor_m.curr_force.force[i];
                    }
                    else
                    {
                        old_force[i] = current_training.traj[i][current_training.current_count-1];
                    }
                }
                else
                {
                        // Read the new force from the trajectory array
                    new_force[i] = current_training.traj[i][current_training.current_count];
                    
                    // If at the beginning of the trajectory, the old force is the current force.
                    //   Otherwise, it is the previous force in the trajectory array.
                    if ( current_training.current_count == 0 )
                    {
                        old_force[i] = maglev_m.current_position.values[i];
                    }
                    else
                    {
                        old_force[i] = current_training.traj[i][current_training.current_count-1];
                    }
                }
        }
        
        // If the training is finished, set the next force to the sliders
        if (!flag_start_training)
        {
                // Set x coordinate
                if (maglev_m.force_control_directions[0])
                        new_force[0] = desired_force_x->value();
                else
                        new_force[0] = desired_position_x->value();
                    
                // Set y coordinate
                if (maglev_m.force_control_directions[1])
                        new_force[1] = desired_force_y->value();
                else
                        new_force[1] = desired_position_y->value();
                    
                // Set z coordinate
                if (maglev_m.force_control_directions[2])
                        new_force[2] = desired_force_z->value();
                else
                        new_force[2] = desired_position_z->value();
                    
                // Set theta_x coordinate
                new_force[3] = desired_rotation_x->value();
                    
                // Set theta_y coordinate
                new_force[4] = desired_rotation_y->value();
                    
                // Set theta_z coordinate
                    new_force[5] = desired_rotation_z->value();
                    
                    // Disable the Start/Stop Training button
                    start_training->label("Start");
                    start_training->clear();
                    start_training->deactivate();
                          current_training.ramp_max *= 5.0;
                          if (trajectory_index->value() < trajectory_index->size())
                          {
                                  trajectory_index->value(trajectory_index->value() + 1);
                          }
        }
        else if ((flag_thumb) && (new_force[0]-3.0*new_force[1]-15 >= new_force[2]))
        {
                printf("Skipping to next force\n");
                current_training.ramp_count = (current_training.ramp_max + current_training.hold_min);
        }
    }
    
    // Run the ramp-and-hold trajectory
    if (current_training.ramp_count < current_training.ramp_max)
    {
            // The imager is ready, so the force can changes
        for (int i=0; i<6; i++)
        {
            float interpolation_constant = ((float) current_training.ramp_count) / ((float) current_training.ramp_max);
            if (maglev_m.force_control_directions[i])
            {
                        maglev_m.desired_force[i] = (new_force[i] - old_force[i]) * interpolation_constant + old_force[i];
                    }
                    else
                    {
                            maglev_m.desired_position.values[i] = (new_force[i] - old_force[i]) * interpolation_constant + old_force[i];
                    }
        }
        current_training.ramp_count += 1;
        
                  // Start the timer again
                  Fl::repeat_timeout(1.0/TRAINING_FREQUENCY, record_training_images, NULL);
    }
    else if (current_training.ramp_count < current_training.ramp_max + current_training.hold_min)
    {
        for (int i=0; i<6; i++)
        {
                if (maglev_m.force_control_directions[i])
                {
                    maglev_m.desired_force[i] = new_force[i];
                }
                else
                {
                        maglev_m.desired_position.values[i] = new_force[i];
                }
        }
        current_training.ramp_count+=1;
        
                  // Start the timer again
                  Fl::repeat_timeout(1.0/TRAINING_FREQUENCY, record_training_images, NULL);
    }
    else if ( current_training.ramp_count == ( current_training.ramp_max + current_training.hold_min ) )
    {
        // The force is ready
        flag_force_ready = true;
        current_training.ramp_count = 0;
        
        if (flag_start_training)
        {
                          // Start the timer again
                          Fl::repeat_timeout(1.0/TRAINING_FREQUENCY, record_training_images, NULL);
                  }
                  else
                  {
                          // Reset the training button
                          start_training->activate();
                          current_training.ramp_max /= 5.0;
                  }
    }
    }
}

//=========================================================
//======= The main loop which handles the graphic  ========
//========================================================= 
int main() {
  { control_window = new Fl_Double_Window(945, 745, "Fingernail Imaging Calibration Software");
    { box_maglev_rotation = new Plot2DView(10, 21, 260, 189, "Maglev Position");
      box_maglev_rotation->box(FL_ENGRAVED_BOX);
      box_maglev_rotation->color(FL_BACKGROUND_COLOR);
      box_maglev_rotation->selection_color(FL_BACKGROUND_COLOR);
      box_maglev_rotation->labeltype(FL_NORMAL_LABEL);
      box_maglev_rotation->labelfont(0);
      box_maglev_rotation->labelsize(14);
      box_maglev_rotation->labelcolor(FL_FOREGROUND_COLOR);
      box_maglev_rotation->align(Fl_Align(FL_ALIGN_TOP));
      box_maglev_rotation->when(FL_WHEN_RELEASE);
    } // Plot2DView* box_maglev_rotation
    { box_maglev_position = new Graph3DAxis(10, 225, 260, 240, "Maglev Position");
      box_maglev_position->box(FL_ENGRAVED_BOX);
      box_maglev_position->color(FL_BACKGROUND_COLOR);
      box_maglev_position->selection_color(FL_BACKGROUND_COLOR);
      box_maglev_position->labeltype(FL_NORMAL_LABEL);
      box_maglev_position->labelfont(0);
      box_maglev_position->labelsize(14);
      box_maglev_position->labelcolor(FL_FOREGROUND_COLOR);
      box_maglev_position->align(Fl_Align(FL_ALIGN_TOP));
      box_maglev_position->when(FL_WHEN_RELEASE);
    } // Graph3DAxis* box_maglev_position
    { display_force = new CubeView(10, 469, 260, 257, "Display Force");
      display_force->box(FL_ENGRAVED_BOX);
      display_force->color(FL_BACKGROUND_COLOR);
      display_force->selection_color(FL_BACKGROUND_COLOR);
      display_force->labeltype(FL_NORMAL_LABEL);
      display_force->labelfont(0);
      display_force->labelsize(14);
      display_force->labelcolor(FL_FOREGROUND_COLOR);
      display_force->align(Fl_Align(FL_ALIGN_BOTTOM));
      display_force->when(FL_WHEN_RELEASE);
    } // CubeView* display_force
    { Fl_Tabs* o = new Fl_Tabs(275, 20, 635, 705);
      { maglev_position = new Fl_Group(280, 55, 625, 620, "Maglev");
        { position_gain_sliders = new Fl_Group(295, 78, 595, 478, "Position Control PID Gains");
          position_gain_sliders->box(FL_BORDER_FRAME);
          position_gain_sliders->color((Fl_Color)34);
          { position_gain_sliders_x = new Fl_Group(337, 95, 130, 200, "x-direction");
            { position_gain_x_P = new Fl_Value_Slider(337, 95, 30, 200, "Kp");
              position_gain_x_P->minimum(3000);
              position_gain_x_P->maximum(0);
              position_gain_x_P->step(100);
              position_gain_x_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_x_P
            { position_gain_x_I = new Fl_Value_Slider(382, 95, 30, 200, "Ki");
              position_gain_x_I->minimum(100);
              position_gain_x_I->maximum(0);
              position_gain_x_I->step(5);
              position_gain_x_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_x_I
            { position_gain_x_D = new Fl_Value_Slider(427, 95, 30, 200, "Kd");
              position_gain_x_D->minimum(20);
              position_gain_x_D->maximum(0);
              position_gain_x_D->step(1);
              position_gain_x_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_x_D
            position_gain_sliders_x->end();
          } // Fl_Group* position_gain_sliders_x
          { position_gain_sliders_y = new Fl_Group(528, 95, 130, 200, "y-direction");
            { position_gain_y_P = new Fl_Value_Slider(528, 95, 30, 200, "Kp");
              position_gain_y_P->minimum(3000);
              position_gain_y_P->maximum(0);
              position_gain_y_P->step(100);
              position_gain_y_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_y_P
            { position_gain_y_I = new Fl_Value_Slider(573, 95, 30, 200, "Ki");
              position_gain_y_I->minimum(100);
              position_gain_y_I->maximum(0);
              position_gain_y_I->step(5);
              position_gain_y_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_y_I
            { position_gain_y_D = new Fl_Value_Slider(623, 95, 30, 200, "Kd");
              position_gain_y_D->minimum(20);
              position_gain_y_D->maximum(0);
              position_gain_y_D->step(1);
              position_gain_y_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_y_D
            position_gain_sliders_y->end();
          } // Fl_Group* position_gain_sliders_y
          { position_gain_sliders_z = new Fl_Group(705, 95, 152, 200, "z-direction");
            { position_gain_z_P = new Fl_Value_Slider(718, 95, 30, 200, "Kp");
              position_gain_z_P->minimum(10000);
              position_gain_z_P->maximum(0);
              position_gain_z_P->step(500);
              position_gain_z_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_z_P
            { position_gain_z_I = new Fl_Value_Slider(763, 95, 30, 200, "Ki");
              position_gain_z_I->minimum(100);
              position_gain_z_I->maximum(0);
              position_gain_z_I->step(5);
              position_gain_z_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_z_I
            { position_gain_z_D = new Fl_Value_Slider(808, 95, 30, 200, "Kd");
              position_gain_z_D->minimum(20);
              position_gain_z_D->maximum(0);
              position_gain_z_D->step(1);
              position_gain_z_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* position_gain_z_D
            position_gain_sliders_z->end();
          } // Fl_Group* position_gain_sliders_z
          { rotation_gain_sliders_x = new Fl_Group(334, 331, 130, 205, "x-rotation");
            { rotation_gain_x_P = new Fl_Value_Slider(334, 331, 30, 205, "Kp");
              rotation_gain_x_P->minimum(100);
              rotation_gain_x_P->maximum(0);
              rotation_gain_x_P->step(5);
              rotation_gain_x_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_x_P
            { rotation_gain_x_I = new Fl_Value_Slider(379, 331, 30, 205, "Ki");
              rotation_gain_x_I->minimum(100);
              rotation_gain_x_I->maximum(0);
              rotation_gain_x_I->step(5);
              rotation_gain_x_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_x_I
            { rotation_gain_x_D = new Fl_Value_Slider(424, 331, 30, 205, "Kd");
              rotation_gain_x_D->minimum(0.2);
              rotation_gain_x_D->maximum(0);
              rotation_gain_x_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_x_D
            rotation_gain_sliders_x->end();
          } // Fl_Group* rotation_gain_sliders_x
          { rotation_gain_sliders_y = new Fl_Group(530, 331, 130, 205, "y-rotation");
            { rotation_gain_y_P = new Fl_Value_Slider(530, 331, 30, 205, "Kp");
              rotation_gain_y_P->minimum(100);
              rotation_gain_y_P->maximum(0);
              rotation_gain_y_P->step(5);
              rotation_gain_y_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_y_P
            { rotation_gain_y_I = new Fl_Value_Slider(575, 331, 30, 205, "Ki");
              rotation_gain_y_I->minimum(100);
              rotation_gain_y_I->maximum(0);
              rotation_gain_y_I->step(5);
              rotation_gain_y_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_y_I
            { rotation_gain_y_D = new Fl_Value_Slider(620, 331, 30, 205, "Kd");
              rotation_gain_y_D->minimum(0.2);
              rotation_gain_y_D->maximum(0);
              rotation_gain_y_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_y_D
            rotation_gain_sliders_y->end();
          } // Fl_Group* rotation_gain_sliders_y
          { rotation_gain_sliders_z = new Fl_Group(715, 331, 130, 205, "z-rotation");
            { rotation_gain_z_P = new Fl_Value_Slider(715, 331, 30, 205, "Kp");
              rotation_gain_z_P->minimum(20);
              rotation_gain_z_P->maximum(0);
              rotation_gain_z_P->step(1);
              rotation_gain_z_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_z_P
            { rotation_gain_z_I = new Fl_Value_Slider(760, 331, 30, 205, "Ki");
              rotation_gain_z_I->minimum(100);
              rotation_gain_z_I->maximum(0);
              rotation_gain_z_I->step(5);
              rotation_gain_z_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_z_I
            { rotation_gain_z_D = new Fl_Value_Slider(805, 331, 30, 205, "Kd");
              rotation_gain_z_D->minimum(0.2);
              rotation_gain_z_D->maximum(0);
              rotation_gain_z_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* rotation_gain_z_D
            rotation_gain_sliders_z->end();
          } // Fl_Group* rotation_gain_sliders_z
          position_gain_sliders->end();
        } // Fl_Group* position_gain_sliders
        { button_maglev_connect_separate = new Fl_Button(360, 585, 110, 35, "Connect");
          button_maglev_connect_separate->type(1);
          button_maglev_connect_separate->callback((Fl_Callback*)cb_button_maglev_connect_separate);
        } // Fl_Button* button_maglev_connect_separate
        { button_maglev_lift_land_separate = new Fl_Button(530, 585, 105, 35, "Lift/Land");
          button_maglev_lift_land_separate->type(1);
          button_maglev_lift_land_separate->callback((Fl_Callback*)cb_button_maglev_lift_land_separate);
        } // Fl_Button* button_maglev_lift_land_separate
        { slider_maglev_frequency = new Fl_Value_Slider(365, 646, 250, 29, "Frequency");
          slider_maglev_frequency->type(1);
          slider_maglev_frequency->box(FL_BORDER_BOX);
          slider_maglev_frequency->color((Fl_Color)42);
          slider_maglev_frequency->selection_color(FL_RED);
          slider_maglev_frequency->minimum(100);
          slider_maglev_frequency->maximum(1500);
          slider_maglev_frequency->step(10);
          slider_maglev_frequency->value(1000);
          slider_maglev_frequency->textsize(14);
          slider_maglev_frequency->callback((Fl_Callback*)cb_slider_maglev_frequency);
        } // Fl_Value_Slider* slider_maglev_frequency
        { check_calibrate_thumb = new Fl_Check_Button(675, 585, 210, 45, "Check This Box for Thumb");
          check_calibrate_thumb->down_box(FL_DOWN_BOX);
          check_calibrate_thumb->callback((Fl_Callback*)cb_check_calibrate_thumb);
          check_calibrate_thumb->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
        } // Fl_Check_Button* check_calibrate_thumb
        maglev_position->end();
      } // Fl_Group* maglev_position
      { force_controller = new Fl_Group(280, 74, 614, 647, "Force Controller");
        force_controller->box(FL_FLAT_BOX);
        force_controller->hide();
        { force_gain_sliders = new Fl_Group(285, 89, 460, 385, "Force Control PID Gains");
          force_gain_sliders->box(FL_ENGRAVED_FRAME);
          { force_gain_sliders_x = new Fl_Group(290, 106, 120, 350, "x Force");
            { force_gain_x_P = new Fl_Value_Slider(290, 106, 30, 350, "Kp");
              force_gain_x_P->minimum(5);
              force_gain_x_P->maximum(0);
              force_gain_x_P->step(0.1);
              force_gain_x_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_x_P
            { force_gain_x_I = new Fl_Value_Slider(335, 106, 30, 350, "Ki");
              force_gain_x_I->minimum(100);
              force_gain_x_I->maximum(0);
              force_gain_x_I->step(0.5);
              force_gain_x_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_x_I
            { force_gain_x_D = new Fl_Value_Slider(380, 106, 30, 350, "Kd");
              force_gain_x_D->minimum(50);
              force_gain_x_D->maximum(0);
              force_gain_x_D->step(1);
              force_gain_x_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_x_D
            force_gain_sliders_x->end();
          } // Fl_Group* force_gain_sliders_x
          { force_gain_sliders_y = new Fl_Group(455, 106, 120, 350, "y Force");
            { force_gain_y_P = new Fl_Value_Slider(455, 106, 30, 350, "Kp");
              force_gain_y_P->minimum(5);
              force_gain_y_P->maximum(0);
              force_gain_y_P->step(0.1);
              force_gain_y_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_y_P
            { force_gain_y_I = new Fl_Value_Slider(500, 106, 30, 350, "Ki");
              force_gain_y_I->minimum(100);
              force_gain_y_I->maximum(0);
              force_gain_y_I->step(0.5);
              force_gain_y_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_y_I
            { force_gain_y_D = new Fl_Value_Slider(545, 106, 30, 350, "Kd");
              force_gain_y_D->minimum(50);
              force_gain_y_D->maximum(0);
              force_gain_y_D->step(1);
              force_gain_y_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_y_D
            force_gain_sliders_y->end();
          } // Fl_Group* force_gain_sliders_y
          { force_gain_sliders_z = new Fl_Group(620, 106, 120, 350, "z Force");
            { force_gain_z_P = new Fl_Value_Slider(620, 106, 30, 350, "Kp");
              force_gain_z_P->minimum(5);
              force_gain_z_P->maximum(0);
              force_gain_z_P->step(0.1);
              force_gain_z_P->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_z_P
            { force_gain_z_I = new Fl_Value_Slider(665, 106, 30, 350, "Ki");
              force_gain_z_I->minimum(100);
              force_gain_z_I->maximum(0);
              force_gain_z_I->step(0.5);
              force_gain_z_I->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_z_I
            { force_gain_z_D = new Fl_Value_Slider(710, 106, 30, 350, "Kd");
              force_gain_z_D->minimum(50);
              force_gain_z_D->maximum(0);
              force_gain_z_D->step(1);
              force_gain_z_D->callback((Fl_Callback*)update_controller_gains);
            } // Fl_Value_Slider* force_gain_z_D
            force_gain_sliders_z->end();
          } // Fl_Group* force_gain_sliders_z
          force_gain_sliders->end();
        } // Fl_Group* force_gain_sliders
        { target_forces = new Fl_Group(759, 89, 135, 320, "Desired Forces");
          target_forces->box(FL_ENGRAVED_FRAME);
          { desired_force_x = new Fl_Value_Slider(764, 94, 30, 295, "Fx");
            desired_force_x->minimum(6);
            desired_force_x->maximum(-6);
            desired_force_x->step(0.25);
            desired_force_x->callback((Fl_Callback*)update_desired_force);
          } // Fl_Value_Slider* desired_force_x
          { desired_force_y = new Fl_Value_Slider(809, 94, 32, 295, "Fy");
            desired_force_y->minimum(6);
            desired_force_y->maximum(-6);
            desired_force_y->step(0.25);
            desired_force_y->callback((Fl_Callback*)update_desired_force);
          } // Fl_Value_Slider* desired_force_y
          { desired_force_z = new Fl_Value_Slider(854, 94, 30, 295, "Fz");
            desired_force_z->minimum(-0.5);
            desired_force_z->maximum(-15);
            desired_force_z->step(0.25);
            desired_force_z->value(-1);
            desired_force_z->callback((Fl_Callback*)update_desired_force);
          } // Fl_Value_Slider* desired_force_z
          target_forces->end();
        } // Fl_Group* target_forces
        { target_positions = new Fl_Group(758, 428, 135, 290, "Desired Positions");
          target_positions->box(FL_ENGRAVED_FRAME);
          { desired_position_x = new Fl_Value_Slider(763, 438, 30, 125, "x_p");
            desired_position_x->minimum(12);
            desired_position_x->maximum(-12);
            desired_position_x->step(1);
            desired_position_x->callback((Fl_Callback*)update_desired_position);
          } // Fl_Value_Slider* desired_position_x
          { desired_position_y = new Fl_Value_Slider(808, 438, 30, 125, "y_p");
            desired_position_y->minimum(12);
            desired_position_y->maximum(-12);
            desired_position_y->step(1);
            desired_position_y->callback((Fl_Callback*)update_desired_position);
          } // Fl_Value_Slider* desired_position_y
          { desired_position_z = new Fl_Value_Slider(853, 438, 30, 125, "z_p");
            desired_position_z->minimum(12);
            desired_position_z->maximum(-12);
            desired_position_z->step(1);
            desired_position_z->callback((Fl_Callback*)update_desired_position);
          } // Fl_Value_Slider* desired_position_z
          { desired_rotation_x = new Fl_Value_Slider(763, 583, 30, 115, "x_r");
            desired_rotation_x->minimum(8);
            desired_rotation_x->maximum(-8);
            desired_rotation_x->step(1);
            desired_rotation_x->callback((Fl_Callback*)update_desired_position);
          } // Fl_Value_Slider* desired_rotation_x
          { desired_rotation_y = new Fl_Value_Slider(808, 583, 30, 115, "y_r");
            desired_rotation_y->minimum(8);
            desired_rotation_y->maximum(-8);
            desired_rotation_y->step(1);
            desired_rotation_y->callback((Fl_Callback*)update_desired_position);
          } // Fl_Value_Slider* desired_rotation_y
          { desired_rotation_z = new Fl_Value_Slider(853, 583, 30, 115, "z_r");
            desired_rotation_z->minimum(8);
            desired_rotation_z->maximum(-8);
            desired_rotation_z->step(1);
            desired_rotation_z->callback((Fl_Callback*)update_desired_position);
          } // Fl_Value_Slider* desired_rotation_z
          target_positions->end();
        } // Fl_Group* target_positions
        { start_force_controller_separate = new Fl_Button(290, 491, 180, 39, "Start Force Controller");
          start_force_controller_separate->type(1);
          start_force_controller_separate->color(FL_RED);
          start_force_controller_separate->selection_color((Fl_Color)2);
          start_force_controller_separate->callback((Fl_Callback*)cb_start_force_controller_separate);
        } // Fl_Button* start_force_controller_separate
        { Fl_Button* o = new Fl_Button(295, 555, 170, 25, "Save new gains");
          o->callback((Fl_Callback*)cb_Save);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(295, 580, 170, 25, "Save Force");
          o->callback((Fl_Callback*)cb_Save1);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(295, 605, 170, 25, "Stop Save");
          o->callback((Fl_Callback*)cb_Stop);
        } // Fl_Button* o
        { system_id = new Fl_Group(479, 505, 250, 178, "System Identification Parameters");
          system_id->box(FL_ENGRAVED_BOX);
          { slide_force_magnitude = new Fl_Value_Slider(497, 528, 200, 20, "Force Frequency Mantissa (a)");
            slide_force_magnitude->type(1);
            slide_force_magnitude->box(FL_BORDER_BOX);
            slide_force_magnitude->color((Fl_Color)42);
            slide_force_magnitude->selection_color(FL_RED);
            slide_force_magnitude->minimum(0.1);
            slide_force_magnitude->maximum(0.9);
            slide_force_magnitude->step(0.1);
            slide_force_magnitude->value(0.1);
            slide_force_magnitude->textsize(14);
          } // Fl_Value_Slider* slide_force_magnitude
          { slide_force_power = new Fl_Value_Slider(494, 588, 200, 20, "Force Frequency Power (b)");
            slide_force_power->type(1);
            slide_force_power->box(FL_BORDER_BOX);
            slide_force_power->color((Fl_Color)42);
            slide_force_power->selection_color(FL_RED);
            slide_force_power->minimum(-3);
            slide_force_power->maximum(3);
            slide_force_power->step(1);
            slide_force_power->textsize(14);
          } // Fl_Value_Slider* slide_force_power
          { force_frequency = new Fl_Text_Display(499, 648, 195, 20, "Frequency");
          } // Fl_Text_Display* force_frequency
          system_id->end();
        } // Fl_Group* system_id
        force_controller->end();
      } // Fl_Group* force_controller
      { camera_control = new Fl_Group(275, 55, 635, 670, "Camera Control");
        camera_control->box(FL_ENGRAVED_FRAME);
        camera_control->hide();
        { camera_settings = new Fl_Group(285, 519, 625, 197, "Camera Settings");
          camera_settings->box(FL_ENGRAVED_FRAME);
          { camera_brightness = new Fl_Value_Slider(293, 543, 231, 21, "Brightness");
            camera_brightness->type(1);
            camera_brightness->textsize(14);
            camera_brightness->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Value_Slider* camera_brightness
          { camera_exposure = new Fl_Value_Slider(293, 580, 230, 20, "Exposure");
            camera_exposure->type(1);
            camera_exposure->textsize(14);
            camera_exposure->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Value_Slider* camera_exposure
          { camera_gamma = new Fl_Value_Slider(294, 616, 230, 20, "Gamma");
            camera_gamma->type(1);
            camera_gamma->textsize(14);
            camera_gamma->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Value_Slider* camera_gamma
          { camera_shutter = new Fl_Value_Slider(295, 650, 230, 20, "Shutter");
            camera_shutter->type(1);
            camera_shutter->textsize(14);
            camera_shutter->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Value_Slider* camera_shutter
          { camera_framerate = new Fl_Value_Slider(295, 685, 230, 20, "Frame rate");
            camera_framerate->type(1);
            camera_framerate->textsize(14);
            camera_framerate->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Value_Slider* camera_framerate
          { camera_gain = new Fl_Value_Slider(620, 682, 230, 20, "Gain");
            camera_gain->type(1);
            camera_gain->textsize(14);
            camera_gain->align(Fl_Align(FL_ALIGN_RIGHT));
          } // Fl_Value_Slider* camera_gain
          { camera_load_settings = new Fl_Button(675, 595, 140, 35, "Load Settings");
          } // Fl_Button* camera_load_settings
          { camera_save_settings = new Fl_Button(675, 535, 140, 35, "Save Settings");
          } // Fl_Button* camera_save_settings
          camera_settings->end();
        } // Fl_Group* camera_settings
        { button_start_camera_separate = new Fl_Button(340, 393, 150, 45, "Start Camera");
          button_start_camera_separate->type(1);
          button_start_camera_separate->callback((Fl_Callback*)cb_button_start_camera_separate);
        } // Fl_Button* button_start_camera_separate
        { Fl_Button* o = new Fl_Button(595, 401, 40, 30, "@>");
          o->box(FL_PLASTIC_UP_BOX);
          o->down_box(FL_PLASTIC_DOWN_BOX);
          o->callback((Fl_Callback*)cb_);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(645, 401, 40, 30, "@square");
          o->box(FL_PLASTIC_UP_BOX);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(695, 401, 40, 30, "@|>");
          o->box(FL_PLASTIC_UP_BOX);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(745, 401, 40, 30, "@<|");
          o->box(FL_PLASTIC_UP_BOX);
        } // Fl_Button* o
        { button_record = new Fl_Button(795, 401, 40, 30, "@circle");
          button_record->type(1);
          button_record->box(FL_PLASTIC_UP_BOX);
          button_record->labelcolor(FL_RED);
          button_record->callback((Fl_Callback*)cb_button_record);
        } // Fl_Button* button_record
        { Fl_Value_Slider* o = new Fl_Value_Slider(324, 454, 515, 30, "Frame");
          o->type(1);
          o->box(FL_PLASTIC_UP_BOX);
          o->maximum(200);
          o->step(1);
          o->textsize(14);
          o->align(Fl_Align(FL_ALIGN_BOTTOM_LEFT));
        } // Fl_Value_Slider* o
        { image_display_b = new ImageDisplay(340, 75, 495, 305, "Display Image");
          image_display_b->box(FL_ENGRAVED_FRAME);
          image_display_b->color(FL_BACKGROUND_COLOR);
          image_display_b->selection_color(FL_BACKGROUND_COLOR);
          image_display_b->labeltype(FL_NORMAL_LABEL);
          image_display_b->labelfont(0);
          image_display_b->labelsize(14);
          image_display_b->labelcolor(FL_FOREGROUND_COLOR);
          image_display_b->align(Fl_Align(FL_ALIGN_CENTER));
          image_display_b->when(FL_WHEN_RELEASE);
        } // ImageDisplay* image_display_b
        camera_control->end();
      } // Fl_Group* camera_control
      { training_trajectories = new Fl_Group(280, 55, 615, 185, "Training");
        training_trajectories->hide();
        { Fl_Button* o = new Fl_Button(280, 80, 160, 25, "Select file");
          o->callback((Fl_Callback*)cb_Select);
        } // Fl_Button* o
        { training_file_name_separate = new Fl_Input(460, 100, 320, 27, "Trajectory File:");
          training_file_name_separate->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Input* training_file_name_separate
        { read_trajectory_file_separate = new Fl_Button(280, 105, 160, 25, "Read in Trajectory");
          read_trajectory_file_separate->callback((Fl_Callback*)cb_read_trajectory_file_separate);
        } // Fl_Button* read_trajectory_file_separate
        { Fl_Button* o = new Fl_Button(280, 130, 160, 25, "Start Training");
          o->callback((Fl_Callback*)cb_Start);
        } // Fl_Button* o
        { Fl_Input* o = new Fl_Input(460, 160, 320, 28, "Training Record:");
          o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        } // Fl_Input* o
        { new Fl_Button(280, 155, 160, 25, "Pause");
        } // Fl_Button* o
        { new Fl_Button(280, 180, 160, 25, "Stop Training");
        } // Fl_Button* o
        training_trajectories->end();
      } // Fl_Group* training_trajectories
      { all_together = new Fl_Group(275, 55, 635, 670, "All Together");
        all_together->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        all_together->hide();
        { image_display_m = new ImageDisplay(330, 70, 530, 400, "Display Image");
          image_display_m->box(FL_ENGRAVED_FRAME);
          image_display_m->color(FL_BACKGROUND_COLOR);
          image_display_m->selection_color(FL_BACKGROUND_COLOR);
          image_display_m->labeltype(FL_NORMAL_LABEL);
          image_display_m->labelfont(0);
          image_display_m->labelsize(14);
          image_display_m->labelcolor(FL_FOREGROUND_COLOR);
          image_display_m->align(Fl_Align(FL_ALIGN_CENTER));
          image_display_m->when(FL_WHEN_RELEASE);
        } // ImageDisplay* image_display_m
        { trajectory_index = new Fl_Choice(470, 490, 60, 30, "TrajID");
          trajectory_index->down_box(FL_BORDER_BOX);
          trajectory_index->callback((Fl_Callback*)generate_trajectory_file);
          // Put initialization code here
    // Add an invisible, blank item to the list
    trajectory_index->add("<nothing>",0,0,0,FL_MENU_INVISIBLE);
    // Add each trajectory to the list
    int order[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};
    char temp[2];
    for (int i=1; i<=18; i++)
    {
            sprintf(temp, "%02d", order[i-1]);
            trajectory_index->add(temp);
    }
    // Set the default trajectory
    trajectory_index->value(1);
            } // Fl_Choice* trajectory_index
            { training_percent = new Fl_Output(560, 490, 170, 30);
              // Initialization code here
    // Change the text color
    training_percent->textcolor(FL_DARK_RED);
            } // Fl_Output* training_percent
            { training_file_name = new Fl_Output(385, 541, 515, 34, "Trajectory File:");
              training_file_name->align(Fl_Align(FL_ALIGN_TOP_LEFT));
            } // Fl_Output* training_file_name
            { training_progress = new Fl_Progress(385, 585, 515, 35, "Training Progress");
              training_progress->align(Fl_Align(FL_ALIGN_BOTTOM));
              // Initialization code here
    // Change the bar color
    //training_progress->color(FL_DARK_GREEN);
    training_progress->color2(FL_DARK_RED);
            } // Fl_Progress* training_progress
            { save_data = new Fl_Button(780, 485, 80, 40, "Save Data");
              save_data->type(1);
              save_data->callback((Fl_Callback*)cb_save_data);
            } // Fl_Button* save_data
            { subject_index = new Fl_Choice(314, 548, 60, 30, "Subj");
              subject_index->down_box(FL_BORDER_BOX);
              // Put initialization code here
            // Add an invisible, blank item to the list
            subject_index->add("<nothing>",0,0,0,FL_MENU_INVISIBLE);
            // Add each finger to the list
            char temp[2];
            for (int i=1; i<=32; i++)
            {
                sprintf(temp, "%02d", i);
                subject_index->add(temp);
            }
            // Set the default subject
            subject_index->value(1);
            } // Fl_Choice* subject_index
            { trajectory_type = new Fl_Choice(288, 488, 85, 25);
              trajectory_type->down_box(FL_BORDER_BOX);
              trajectory_type->callback((Fl_Callback*)generate_trajectory_file);
              // Put initialization code here
                // Add each trajectory to the list
                trajectory_type->add("Cart.");
                trajectory_type->add("Cyl.");

                // Set the default trajectory type
                trajectory_type->value(0);
            } // Fl_Choice* trajectory_type
            { finger_index = new Fl_Choice(289, 518, 85, 25);
              finger_index->down_box(FL_BORDER_BOX);
              finger_index->callback((Fl_Callback*)change_finger);
              // Put initialization code here
                // Add an invisible, blank item to the list
                finger_index->add("<nothing>",0,0,0,FL_MENU_INVISIBLE);

                // Add each finger to the list
                finger_index->add("thumb");
                finger_index->add("index");
                finger_index->add("middle");
                finger_index->add("ring");
                finger_index->add("little");

                // Set the default finger
                finger_index->value(2);
                generate_trajectory_file();
            } // Fl_Choice* finger_index
            { button_maglev_connect = new Fl_Button(284, 583, 90, 35, "Connect");
              button_maglev_connect->type(1);
              button_maglev_connect->callback((Fl_Callback*)cb_button_maglev_connect);
            } // Fl_Button* button_maglev_connect
            { button_maglev_lift_land = new Fl_Button(284, 618, 90, 33, "Lift Off");
              button_maglev_lift_land->type(1);
              button_maglev_lift_land->callback((Fl_Callback*)cb_button_maglev_lift_land);
            } // Fl_Button* button_maglev_lift_land
            { button_start_camera = new Fl_Button(284, 652, 90, 34, "Camera");
              button_start_camera->type(1);
              button_start_camera->callback((Fl_Callback*)cb_button_start_camera);
            } // Fl_Button* button_start_camera
            { start_force_controller = new Fl_Button(284, 686, 90, 34, "Controller");
              start_force_controller->type(1);
              start_force_controller->callback((Fl_Callback*)cb_start_force_controller);
            } // Fl_Button* start_force_controller
            { start_training = new Fl_Button(585, 640, 110, 40, "Start");
              start_training->type(1);
              start_training->callback((Fl_Callback*)cb_start_training);
            } // Fl_Button* start_training
            { Fl_Box* o = new Fl_Box(460, 680, 358, 40, "watch out the Maglev position");
              o->labelfont(14);
              o->labelsize(18);
            } // Fl_Box* o
            all_together->end();
          } // Fl_Group* all_together
          o->end();
        } // Fl_Tabs* o
        control_window->end();
      } // Fl_Double_Window* control_window
      control_window->show();
    return Fl::run();
}
//=========================================================
//=========================================================
